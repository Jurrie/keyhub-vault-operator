package controllers

import (
	"crypto/dsa"
	"crypto/ecdsa"
	"crypto/rsa"
	"crypto/sha1"
	"crypto/x509"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/go-logr/logr"
	"github.com/patrickmn/go-cache"
	"github.com/topicus-education-ops/keyhub-operator/pkg/client/keyhub"
	keyhubv1alpha1 "github.com/topicusonderwijs/keyhub-vault-operator/api/v1alpha1"
	keyhubclient "github.com/topicuskeyhub/go-keyhub"
	"golang.org/x/crypto/pkcs12"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	certUtil "k8s.io/client-go/util/cert"
	keyUtil "k8s.io/client-go/util/keyutil"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type VaultRecordWithGroup struct {
	group  keyhubclient.Group
	record keyhubclient.VaultRecord
}

type KeyHubSecretSyncer struct {
	log          logr.Logger
	client       client.Client
	keyhubCache  *cache.Cache
	keyhubClient *keyhubclient.Client
	cr           *keyhubv1alpha1.KeyHubSecret
	secret       *corev1.Secret
	state        map[string]keyhubv1alpha1.VaultRecordState
	records      map[string]VaultRecordWithGroup
}

func newSyncer(log logr.Logger, client client.Client, keyhubCache *cache.Cache, cr *keyhubv1alpha1.KeyHubSecret, secret *corev1.Secret) *KeyHubSecretSyncer {
	return &KeyHubSecretSyncer{
		log:         log.WithValues("keyhubsecret", cr.Namespace),
		client:      client,
		keyhubCache: keyhubCache,
		cr:          cr,
		secret:      secret,
		state:       make(map[string]keyhubv1alpha1.VaultRecordState),
		records:     make(map[string]VaultRecordWithGroup),
	}
}

func (s *KeyHubSecretSyncer) Sync() error {
	keyhubClient, err := s.getKeyHubClient()
	if err != nil {
		return err
	}
	s.keyhubClient = keyhubClient

	s.secret.Labels = s.cr.Spec.Template.Labels
	s.secret.Annotations = s.cr.Spec.Template.Annotations

	defer func() { s.cr.Status.RecordState = s.state }()
	return s.fillSecret()
}

func (s *KeyHubSecretSyncer) getKeyHubClient() (*keyhubclient.Client, error) {
	if keyhubClientID, found := s.keyhubCache.Get("ns/" + s.cr.Namespace); found {
		if cachedKeyhubClient, found := s.keyhubCache.Get(keyhubClientID.(string)); found {
			keyhubClient := cachedKeyhubClient.(*keyhubclient.Client)
			s.log.Info("Cached KeyHub client found", "id", keyhubClient.ID, "namespace", s.cr.Namespace)
			return keyhubClient, nil
		}
	}

	// FIXME reqLogger
	reqLogger := s.log.WithValues("Request.Namespace", s.cr.Namespace, "Request.Name", s.cr.Name)
	credentials, err := getKeyHubClientCredentialsForNamespace(reqLogger, s.client, s.cr.Namespace)
	if err != nil {
		return nil, err
	}

	if cachedKeyhubClient, found := s.keyhubCache.Get(credentials.ClientID); found {
		keyhubClient := cachedKeyhubClient.(*keyhubclient.Client)
		s.log.Info("Cached KeyHub client found", "id", keyhubClient.ID)
		s.keyhubCache.Set("ns/"+s.cr.Namespace, keyhubClient.ID, 56*time.Minute)
		return keyhubClient, nil
	}

	s.log.Info("Initializing KeyHub client", "namespace", s.cr.Namespace)
	return s.createKeyHubClient(credentials)
}

func (s *KeyHubSecretSyncer) createKeyHubClient(credentials *ClientCredentials) (*keyhubclient.Client, error) {
	keyhubClient, err := keyhubclient.NewClient(http.DefaultClient, keyhub.URI(), credentials.ClientID, credentials.ClientSecret)
	if err != nil {
		return nil, err
	}

	// Our token is valid for 1hr, use refresh token?
	s.keyhubCache.Set("ns/"+s.cr.Namespace, keyhubClient.ID, 56*time.Minute)
	s.keyhubCache.Set(keyhubClient.ID, keyhubClient, 54*time.Minute)

	s.log.Info("KeyHub client initialized", "namespace", s.cr.Namespace, "id", keyhubClient.ID)

	return keyhubClient, nil
}

func (s *KeyHubSecretSyncer) fillSecret() error {
	err := s.initVaultRecords()
	if err != nil {
		return err
	}

	// secret type is immutable, k8s will complain if it changes
	s.secret.Type = s.cr.Spec.Template.Type
	if s.secret.Type == "" {
		s.secret.Type = corev1.SecretTypeOpaque
	}
	switch s.secret.Type {
	case corev1.SecretTypeOpaque:
		return s.applyOpaqueSecret()
	case corev1.SecretTypeBasicAuth:
		return s.applyBasicAuthSecret()
	case corev1.SecretTypeSSHAuth:
		return s.applySSHAuthSecret()
	case corev1.SecretTypeTLS:
		return s.applyTLSSecret()
	default:
		return fmt.Errorf("Unsupported secret type: %s", s.secret.Type)
	}
}

func (s *KeyHubSecretSyncer) initVaultRecords() error {
	if records, found := s.keyhubCache.Get("records/" + s.keyhubClient.ID); found {
		// log.Info("Using cached records for client " + s.keyhubClient.ID)
		s.records = records.(map[string]VaultRecordWithGroup)
		return nil
	}

	s.log.Info("keyhub client: groups.list")
	groups, err := s.keyhubClient.Groups.List()
	if err != nil {
		return err
	}

	for _, group := range groups {
		s.log.Info("Found KeyHub group", "uuid", group.UUID, "name", group.Name)
		records, err := s.keyhubClient.Vaults.GetRecords(&group)
		if err != nil {
			return err
		}
		for _, record := range records {
			// log.Info("Found Keyhub vault record", "group", group.UUID, "uuid", record.UUID, "name", record.Name)
			// records = append(records, VaultRecordWithGroup{group: group, record: record})

			s.records[record.UUID] = VaultRecordWithGroup{group: group, record: record}
		}
	}

	s.keyhubCache.Set("records/"+s.keyhubClient.ID, s.records, cache.DefaultExpiration)

	return nil
}

func (s *KeyHubSecretSyncer) applyOpaqueSecret() error {
	data := make(map[string][]byte)
	missing := false
	for _, ref := range s.cr.Spec.Data {
		found := false
		uptodate := false
		for _, r := range s.records {
			// log.Info("Trying", "need", ref.Record, "uuid", r.record.UUID, "name", r.record.Name)
			if ref.Record == r.record.UUID {
				s.log.Info("Matched KeyHub vault record", "key", ref.Name, "uuid", r.record.UUID, "name", r.record.Name, "lastModifiedAt", r.record.LastModifiedAt().UTC().Format(time.RFC3339Nano))

				if s.isRecordInSync(ref, &r.record) {
					uptodate = true
					s.setVaultRecordState(ref, &r.record)
					break
				}

				s.log.Info("Updating KeyHub vault record", "key", ref.Name, "ref", ref.Record, "lastModifiedAt", r.record.LastModifiedAt().UTC().Format(time.RFC3339))
				record, err := s.keyhubClient.Vaults.GetRecord(&r.group, r.record.UUID, keyhubclient.RecordOptions{Secret: true, Audit: true})
				if err != nil {
					return err
				}

				if ref.Property == "username" {
					data[ref.Name] = []byte(record.Username)
				} else if ref.Property == "password" || ref.Property == "" {
					data[ref.Name] = []byte(record.Password())
				} else if ref.Property == "link" {
					data[ref.Name] = []byte(record.URL)
				} else if ref.Property == "file" {
					data[ref.Name] = record.File()
				} else if ref.Property == "lastModifiedAt" {
					data[ref.Name] = []byte(record.LastModifiedAt().UTC().Format(time.RFC3339))
				} else {
					// TODO: report to crd status, just skipping the key, no error
					s.log.Info("Unsupported property", "property", ref.Property)
				}

				s.setVaultRecordState(ref, record)

				found = true
				break
			}
		}

		if !found && !uptodate {
			missing = true
			// TODO: report to crd status
			s.log.Info("No KeyHub vault record found", "key", ref.Name, "ref", ref.Record)
			s.state[ref.Name] = keyhubv1alpha1.VaultRecordState{Record: ref.Record, Message: "Record not found"}
		}
	}

	// Merge KeyHub keys into Secret, keep existing keys (might be added by the application)
	// TODO: check previous key list defined in KeyHubSecret and delete keys
	if s.secret.Data == nil {
		s.secret.Data = data
	} else {
		for k, v := range data {
			s.secret.Data[k] = v
		}
	}

	if missing {
		// TODO: just report to crd status, skip missing key, no error
		return fmt.Errorf("Missing KeyHub vault record(s)")
	}

	return nil
}

func (s *KeyHubSecretSyncer) applyBasicAuthSecret() error {
	if len(s.cr.Spec.Data) != 1 {
		return fmt.Errorf("Expected one key for basic authentication, found %d", len(s.cr.Spec.Data))
	}

	ref := s.cr.Spec.Data[0]

	r, ok := s.records[ref.Record]
	if !ok {
		return fmt.Errorf("Record %s not found for key %s", ref.Record, ref.Name)
	}

	if s.isRecordInSync(ref, &r.record) {
		s.setVaultRecordState(ref, &r.record)
		return nil
	}

	record, err := s.keyhubClient.Vaults.GetRecord(&r.group, r.record.UUID, keyhubclient.RecordOptions{Secret: true, Audit: true})
	if err != nil {
		return err
	}

	s.secret.Data = map[string][]byte{
		corev1.BasicAuthUsernameKey: []byte(record.Username),
		corev1.BasicAuthPasswordKey: []byte(record.Password()),
	}

	s.setVaultRecordState(ref, record)

	return nil
}

func (s *KeyHubSecretSyncer) applySSHAuthSecret() error {
	if len(s.cr.Spec.Data) != 1 {
		return fmt.Errorf("Expected one key for SSH authentication, found %d", len(s.cr.Spec.Data))
	}

	ref := s.cr.Spec.Data[0]
	if ref.Name != "key" {
		return fmt.Errorf("Invalid name '%s', only 'key' is allowed for SSH authentication", ref.Name)
	}

	r, ok := s.records[ref.Record]
	if !ok {
		return fmt.Errorf("Record %s not found for key %s", ref.Record, ref.Name)
	}

	if s.isRecordInSync(ref, &r.record) {
		s.setVaultRecordState(ref, &r.record)
		return nil
	}

	record, err := s.keyhubClient.Vaults.GetRecord(&r.group, r.record.UUID, keyhubclient.RecordOptions{Secret: true, Audit: true})
	if err != nil {
		return err
	}

	if len(record.File()) == 0 {
		return fmt.Errorf("Missing file for record %s", ref.Record)
	}

	s.secret.Data = map[string][]byte{
		corev1.SSHAuthPrivateKey: record.File(),
	}

	s.setVaultRecordState(ref, record)

	return nil
}

func (s *KeyHubSecretSyncer) applyTLSSecret() error {
	if len(s.cr.Spec.Data) < 1 || len(s.cr.Spec.Data) > 2 {
		return fmt.Errorf("Unexpected number of keys for TLS secret, found %d keys", len(s.cr.Spec.Data))
	}

	if len(s.cr.Spec.Data) == 2 {
		var certRef, keyRef keyhubv1alpha1.SecretKeyReference
		for _, ref := range s.cr.Spec.Data {
			if ref.Name == corev1.TLSCertKey {
				certRef = ref
			} else if ref.Name == corev1.TLSPrivateKeyKey {
				keyRef = ref
			}
		}
		if certRef.Name == "" {
			return fmt.Errorf("Missing key '%s' for TLS secret", corev1.TLSCertKey)
		}
		if keyRef.Name == "" {
			return fmt.Errorf("Missing key '%s' for TLS secret", corev1.TLSPrivateKeyKey)
		}

		crt, ok := s.records[certRef.Record]
		if !ok {
			return fmt.Errorf("Record %s not found for key %s", certRef.Record, certRef.Name)
		}

		key, ok := s.records[keyRef.Record]
		if !ok {
			return fmt.Errorf("Record %s not found for key %s", keyRef.Record, keyRef.Name)
		}

		if s.isRecordInSync(certRef, &crt.record) && s.isRecordInSync(keyRef, &key.record) {
			s.setVaultRecordState(certRef, &crt.record)
			s.setVaultRecordState(keyRef, &key.record)
			return nil
		}

		crtRecord, err := s.keyhubClient.Vaults.GetRecord(&crt.group, crt.record.UUID, keyhubclient.RecordOptions{Secret: true, Audit: true})
		if err != nil {
			return err
		}

		keyRecord, err := s.keyhubClient.Vaults.GetRecord(&key.group, key.record.UUID, keyhubclient.RecordOptions{Secret: true, Audit: true})
		if err != nil {
			return err
		}

		if len(crtRecord.File()) == 0 {
			return fmt.Errorf("Missing file for record %s", certRef.Record)
		}

		if len(keyRecord.File()) == 0 {
			return fmt.Errorf("Missing file for record %s", keyRef.Record)
		}

		s.secret.Data = map[string][]byte{
			corev1.TLSCertKey:       crtRecord.File(),
			corev1.TLSPrivateKeyKey: keyRecord.File(),
		}

		certificates, err := certUtil.ParseCertsPEM(crtRecord.File())
		if err != nil {
			return err
		}
		s.setRancherCertificateAnnotations(certificates[0])
	} else {
		ref := s.cr.Spec.Data[0]
		if ref.Name != "pem" && ref.Name != "pkcs12" {
			return fmt.Errorf("Invalid name '%s', only 'pem' or 'pkcs12' is allowed for single key TLS secret", ref.Name)
		}

		r, ok := s.records[ref.Record]
		if !ok {
			return fmt.Errorf("Record %s not found for key %s", ref.Record, ref.Name)
		}

		if s.isRecordInSync(ref, &r.record) {
			s.setVaultRecordState(ref, &r.record)
			return nil
		}

		record, err := s.keyhubClient.Vaults.GetRecord(&r.group, r.record.UUID, keyhubclient.RecordOptions{Secret: true, Audit: true})
		if err != nil {
			return err
		}

		if len(record.File()) == 0 {
			return fmt.Errorf("Missing file for record %s", ref.Record)
		}

		var cert *x509.Certificate
		var key interface{}
		if ref.Name == "pem" {
			certificates, err := certUtil.ParseCertsPEM(record.File())
			if err != nil {
				return err
			}
			if len(certificates) > 1 {
				return fmt.Errorf("File for record %s contains more than one certificate", ref.Record)
			}
			cert = certificates[0]

			key, err = keyUtil.ParsePrivateKeyPEM(record.File())
			if err != nil {
				return err
			}
		} else if ref.Name == "pkcs12" {
			key, cert, err = pkcs12.Decode(record.File(), record.Password())
			if err != nil {
				return err
			}
		}

		certBytes, err := certUtil.EncodeCertificates(cert)
		if err != nil {
			return err
		}

		keyBytes, err := keyUtil.MarshalPrivateKeyToPEM(key.(*rsa.PrivateKey))
		if err != nil {
			return err
		}

		s.secret.Data = map[string][]byte{
			corev1.TLSCertKey:       certBytes,
			corev1.TLSPrivateKeyKey: keyBytes,
		}

		s.setRancherCertificateAnnotations(cert)

		s.setVaultRecordState(ref, record)
	}

	return nil
}

func (s *KeyHubSecretSyncer) setRancherCertificateAnnotations(cert *x509.Certificate) {
	// Rancher 2.0 support
	s.secret.ObjectMeta.Annotations["field.cattle.io/algorithm"] = keyAlgorithmLookup[cert.PublicKeyAlgorithm]
	s.secret.ObjectMeta.Annotations["field.cattle.io/certFingerprint"] = strings.Replace(fmt.Sprintf("% X", sha1.Sum(cert.Raw)), " ", ":", -1)
	s.secret.ObjectMeta.Annotations["field.cattle.io/cn"] = cert.Subject.CommonName
	s.secret.ObjectMeta.Annotations["field.cattle.io/expiresAt"] = cert.NotAfter.UTC().Format(time.RFC3339)
	s.secret.ObjectMeta.Annotations["field.cattle.io/issuedAt"] = cert.NotBefore.UTC().Format(time.RFC3339)
	s.secret.ObjectMeta.Annotations["field.cattle.io/issuer"] = cert.Issuer.CommonName
	s.secret.ObjectMeta.Annotations["field.cattle.io/serialNumber"] = cert.SerialNumber.String()
	s.secret.ObjectMeta.Annotations["field.cattle.io/version"] = strconv.Itoa(cert.Version)

	var publicKeySize int
	switch pub := cert.PublicKey.(type) {
	case *rsa.PublicKey:
		publicKeySize = pub.N.BitLen()
	case *dsa.PublicKey:
		publicKeySize = pub.Q.BitLen()
	case *ecdsa.PublicKey:
		publicKeySize = pub.X.BitLen()
	}
	s.secret.ObjectMeta.Annotations["field.cattle.io/keySize"] = strconv.Itoa(publicKeySize)

	var subjectAlternativeNames []string
	for _, name := range cert.DNSNames {
		subjectAlternativeNames = append(subjectAlternativeNames, strconv.Quote(name))
	}
	for _, ip := range cert.IPAddresses {
		subjectAlternativeNames = append(subjectAlternativeNames, strconv.Quote(ip.String()))
	}
	s.secret.ObjectMeta.Annotations["field.cattle.io/subjectAlternativeNames"] = fmt.Sprintf("[%s]", strings.Join(subjectAlternativeNames, ","))
}

var keyAlgorithmLookup = map[x509.PublicKeyAlgorithm]string{
	x509.RSA:   "RSA",
	x509.DSA:   "DSA",
	x509.ECDSA: "ECDSA",
}

func (s *KeyHubSecretSyncer) isRecordInSync(ref keyhubv1alpha1.SecretKeyReference, record *keyhubclient.VaultRecord) bool {
	if state, found := s.cr.Status.RecordState[ref.Name]; found {
		if state.Record == ref.Record && state.LastModifiedAt != nil && !state.LastModifiedAt.UTC().Before(record.LastModifiedAt().Truncate(time.Second).UTC()) {
			s.log.Info("Record in sync with KeyHub vault record", "key", ref.Name, "ref", ref.Record, "lastModifiedAt", state.LastModifiedAt.UTC().Format(time.RFC3339))
			return true
		}
	}
	return false
}

func (s *KeyHubSecretSyncer) setVaultRecordState(ref keyhubv1alpha1.SecretKeyReference, record *keyhubclient.VaultRecord) {
	lastModifiedAt := metav1.NewTime(record.LastModifiedAt().UTC())
	s.state[ref.Name] = keyhubv1alpha1.VaultRecordState{
		Record:         ref.Record,
		Name:           record.Name,
		LastModifiedAt: &lastModifiedAt}
}
